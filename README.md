# Single molecule tools ([Alex Payne-Dwyer](https://www.linkedin.com/in/alex-payne-dwyer-002311a8/), University of York, UK)

This repository comprises a series of Matlab functions and scripts called **ADEMScode** for tracking and single-molecule quantification of particles in fluorescence images and image sequences, as well as deconvolution, segmentation and simulation. It is broadly useful for localisation microscopy, step-wise photobleaching including Slimfield and SlimVar (see below), SHRIMP, STORM, PALM, FRAP and epifluorescence microscopy data. 

The original version is forked here from [single-molecule-tools](https://awollman.github.io/single-molecule-tools/):  
(authors Adam Wollman and Isabel Llorente-Garcia, c. 2018, coordinated by Mark Leake's research lab in the [Physics of Life group](https://www.york.ac.uk/physics-engineering-technology/research/physics-of-life/)).  

# SlimVar: repository for ADEMScode v2.2

This section introduces the version of ADEMScode software developed at the University of York, UK and used to support SlimVar microscopy analysis in the following publications:

1. [SlimVar: rapid in vivo single-molecule tracking of chromatin regulators in plants](https://www.biorxiv.org/content/10.1101/2024.05.17.594710.abstract)  
AL Payne-Dwyer, GJ Jang, C Dean and MC Leake  
bioRxiv, 2024.05.17.594710

2. [Multifunctional polymerization domains determine the onset of epigenetic silencing in Arabidopsis](https://www.biorxiv.org/content/10.1101/2024.02.15.580496.abstract)  
A Schulten, GJ Jang, A Payne-Dwyer, M Fiedler, ML Nielsen, M Bienz, MC Leake and C Dean  
bioRxiv, 2024.02. 15.580496  

3. [Modular in vivo assembly of Arabidopsis FCA oligomers into condensates competent for RNA 3’ processing](https://doi.org/10.1038/s44318-025-00394-4)  
GJ Jang, AL Payne-Dwyer, R Maple, Z Wu, F Liu, SG Lopez, Y Wang, X Fang, MC Leake and C Dean  
**Now published in EMBO J** (2025) 44: 2056 - 2074  

4. [Single-molecular quantification of flowering control proteins within nuclear condensates in live whole Arabidopsis root](https://link.springer.com/protocol/10.1007/978-1-0716-2221-6_21)  
AL Payne-Dwyer and MC Leake  
Methods in Molecular Biology (Volume 2476): Chromosome Architecture pp 311-328 (2022)  
Also available via [open access preprint](https://arxiv.org/pdf/2108.13743)

Novel functionality here includes distribution-based estimates of periodic clustering in molecular assemblies, as well as scripts for visualising correlated properties of tracks colocalised across two channels.  

## Set-up

To get the code, do one of the following: 
1. set up source control in Matlab with this [MathWorks protocol](https://blogs.mathworks.com/community/2014/10/20/matlab-and-git/)
2. use git to clone the repository, or
3. download directly:
- Click ‘View on Github’ at the top
- Click the green ‘Clone or download’ button and download the whole repository
- Put the folder in your Matlab path and unzip if necessary
- Make sure all code is added to the Matlab path using ‘Set path’

## Input data structure and format

The standard file format for ADEMScode is 16-bit OME TIFF.  The code uses `bioformats` and `bftools` from the [Open Microscopy Environment](https://www.openmicroscopy.org/) under open licence.
In principle, it is therefore also compatible with .czi and other image stack types listed in BioFormats. 

The input image sequence files must be organised in a nested folder hierarchy: `DATASET/DATE/SAMPLE/FIELD/IMAGES`  
i.e. in the format `"\*/2YYY-MM-DD/sample\*/field\*/\*.tif"`.

`mergeFolders` is a macro for arranging folders into this structure, for example if alternating odd- and even-numbered acquisitions correspond to  brightfield and SlimVar sequences for each subsequent field of view.  
It also renames image stack files by timestamp using the metadata.txt files generated by MicroManager 1.4.

## Segmentation

ADEMScode includes various custom functions for segmenting 2D areas of images, for example cells or organelles.  
Each segmentation method creates masks for distinct objects.

`thresholdSegment`: Defines a pixel intensity threshold using various different methods, such as the Otsu threshold.  
`edgeSegment`: Detects edges in the image and dilates to fill in regions in between.  
`watershedSegment`: Requires input segmentation `seedMask` from which a watershed transform is nucleated and applied to the image.  

The output ('**`_segmentation.mat`**') includes `CellObject`: a binary mask array the same size as the input image.
In many cases cropping the input images to the region of interest is more efficient than segmentation, since this avoids having to perform tracking (computationally heavy) outside the region of interest.

## Tracking

The tracking software consists of a series of functions for opening image sequences, tracking bright particles over time and quantifying their intensity.

`tracker`: the main tracking program, whose inputs are the filename (or folder name for unstacked .tifs) and a list of hyperparameters '`p`'.    
`[SpotsCh1, SpotsCh2, frame_average, p, meta_data, image_data, spotImages] = tracker(fileName,p)`

### Parameters and settings
`p` is the parameter structure which is read in from the workspace, or otherwise set in code:  
`readData` set to `0` for data preloaded as `image_label`, or `1` to specify .tif using a prompt.  
`show_output`: an option that can be used to view graphs and manually advance at each stage of the algorithm.  
`Cursor_mode`: set to `1` for the user to manually specify localised foci. The code will return intensity values at this point over the whole time series.  

### Subroutines
`extractImageSequence3`: extracts user set frames from .tif specified by image_label.  It can also open ASCII files and folders full of .tif frames.  
`ImEx1`: uses the OME `bftools` and `bioformats` modules to open various life science image formats.
`LaserOn3`: calculates the first illuminated frame based on the maximum total intensity; for use when the excitation is not triggered by the camera.  
`FrameAverage2`: calculates an image averaged over a set number of frames.  
`findSpots4`: finds candidate spots using a range of deterministic kernel methods including top-hat filtering, Otsu thresholding and/or morphological transformations.  
`findSpotCentre3`: performs iterative Gaussian masking to find spot centre and total intensity.  
`fit2DgaussianFixedCenter2`: fits a constrained elliptical Gaussian mask to find `sigma_x`,`sigma_y` and central intensity.
`MergeCoincidentCandidates2`: will use pairwise distances to remove candidates which are too close to be resolved.  
`iterate1DgaussianFixedCenter2`: finds the width of the point-spread-function (PSF) by masking with Gaussian masks of different sizes.  
`LinkSpots4`: links spots into tracks based on proximity.  

### Output
The output ('**`_TRACKS.mat`**') includes the following:  
`frame_average`: an average of the first few frames in the image sequence for reference.
`SpotsCh1` and `SpotsCh2`: arrays of foci from one image sequence in the respective detector channels 1 and 2. Each row corresponds to an individual localisation. The columns contain the following information:  
1.	X coordinate (pixels)
2.	Y coordinate (pixels)
3.	Clipping_flag (not used)
4.	Mean local background pixel intensity (ADUs)
5.	Total spot intensity, background corrected (this is the value in ADU detector counts used to calculate the track stoichiometry)
6.	X spot sigma width (pixels)
7.	Y spot sigma width (pixels)
8.	Peak intensity in a fitted Gaussian (ADUs)
9.	Frame number this foci was found in
10.	Track number, foci in the same track have the same track number
11.	Signal to noise ratio (this is used later for the **sifting** step)
12.	Frame in which laser exposure began.

## Characteristic molecular brightness

To determine stoichiometry, periodicity or total molecule number, one must first estimate the typical intensity of a single fluorophore: the _characteristic molecular brightness_.
Broadly, three methods are available to do this, listed in order of increasing accuracy for the specific use case:

### In vitro
1. Immobilise purified fluorophores to a surface, then track and find the average intensity of known single-molecule events (column 5 of SpotCh1/2 in ADU counts or photons).

### In vivo
2. Extensively photobleach a sample, then track and find the average intensity of assumed single-molecule events (column 5 of SpotCh1/2 in ADU counts or photons).
3. Track (or overtrack) and apply the Chung-Kennedy filter, then calculate the photobleaching step heights (in ADU counts or photons).

#### Overtracking
`overTracker.m`: overtracking is a method to see single photobleach steps by tracking them beyond the time at which they fall below the SNR threshold for sifting, typically due to complete photobleaching. Plotting the intensity distribution here again is useful as you should have one clear peak at the characteristic molecular brightness and one close to the detector baseline.

#### Filtering
`CKall`: the intensity of foci are typically too noisy to extract steps using direct averages, so edge-preserving filters are needed to smooth the traces. This script will run a Chung-Kennedy filter over the data and plot the individual photobleaching traces.  Aligning the plateaus and plotting the filtered intensity yields the distribution of photobleaching step heights. The modal value is the characteristic molecular brightness.

## Analysis for Stoichiometry, Diffusivity and Colocalisation

This step applies sifting (and if specified, segmentation masks) to the foci then constructs the sifted tracks. 
It summarises the track properties including stoichiometry and diffusivity, and tests for pairwise colocalisation between tracks.  

### Parameters and settings
`params` is the parameter structure which is read in from the workspace, or otherwise set in code:

### Routines

`colocalisedTrackAnalyser` is a function that runs on a single file containing two colour channels.
Inputs: tracking file (`TRACKS.mat`) containing the `SpotCh1` and `SpotCh2` arrays; optional segmentation mask '`_segmentation.mat`'; image filename and a hyperparameter structure `params`.  
Outputs: an output file (`OUTPUT.mat`) containing the `trackArrayCh1` and `trackArrayCh2` arrays that describe stoichiometry, diffusivity and other properties by track.

`sampleTrackAnalyser` performs the analyser function in a loop over multiple image files in a nested folder structure, thereby aggregating results corresponding to multiple fields of view in the same dataset.

### Output

The output ('**`_output.mat`**') includes the arrays `TrackArrayCh1` and `TrackArrayCh2` collated from all image sequences in the two respective detector channels.  
Each row contains the information for an individual sifted track. The columns contain the following information:  
1.	Segment index
2.	Initial brightness of track (ADU detector counts; when normalised by the characteristic molecular brightness, this is the value that gives the track's stoichiometry as published)
3.	Diffusivity (µm²/s; this is the track's diffusivity as published)
4.	Diffusivity from first displacement (µm²/s)
5.	Mean spot radius (pixels)
6.	Track index within this channel
7.	Filename ID
8.	Index of the longest colocalised track in the other channel
9.	Number of linked frames in this track
10. Index of the colocalised track in the other channel
11. Mean distance between tracks (pixels)
12. Track diameter parallel to segment long axis (pixels)
13. Track diameter perpendicular to segment long axis (pixels)
14. Length of track (in frames; post sifting so all tracks have 3+ frames)

This script also appends the following rows to the SpotCh1/2 arrays for the sifted foci:
13.	Index of colocalised foci in the other channel
14.	Overlap integral (a metric to estimate extent of colocalisation)
15.	Track index of colocalised foci in the other channel
16.	Distance between colocalised foci (pixels)
17.	Field of view index
18.  Segment index


## Analysis for Stoichiometry Periodicity

``

## Analysis for Total Protein Number (aka. total 'copy' number of labelled molecules)

For specific microbiology datasets, the `CoPro` pipeline in ADEMScode is appropriate (see )
In the SlimVar publication (Payne-Dwyer et al, 2024), the total number of proteins per plant nucleus are estimated from the images using an ImageJ script instead of a MATLAB script.

