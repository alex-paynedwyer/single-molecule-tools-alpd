# Single molecule tools ([Alex Payne-Dwyer](https://www.linkedin.com/in/alex-payne-dwyer-002311a8/), University of York, UK)

This repository comprises a package of Matlab functions and scripts called **ADEMScode** for segmentation, tracking and single-molecule quantification of particles in fluorescence images and image sequences. 

This package is focused on the analysis of Slimfield and **SlimVar** fluorescence microscopy data (see below); it may also be broadly useful for localisation microscopy, STORM, PALM, FRAP, step-wise photobleaching and epifluorescence microscopy data. 

The original version, ADEMScode v2.1, was authored by Adam Wollman and Isabel Llorente-Garcia, c. 2018, coordinated by Mark Leake's research lab in the [Physics of Life group](https://www.york.ac.uk/physics-engineering-technology/research/physics-of-life/). It was forked here from [single-molecule-tools](https://awollman.github.io/single-molecule-tools/) maintained by Adam Wollman, now at Newcastle University, UK, and on which the following guide is also based.  

Please also see [PySTACHIO](https://github.com/ejh516/pystachio-smt); it is an open-source port of ADEMScode v2.1 written in Python 3 by researchers at York's Physics of Life group as described in [Shepherd et al. 2021](https://doi.org/10.1016/j.csbj.2021.07.004).

# SlimVar: repository for ADEMScode v2.2

This section introduces the ADEMScode version 2.2 software developed by Alex Payne-Dwyer at the University of York, UK and used to support SlimVar microscopy analysis in the following publications:

1. [SlimVar: rapid in vivo single-molecule tracking of chromatin regulators in plants](https://www.biorxiv.org/content/10.1101/2024.05.17.594710.abstract)  
AL Payne-Dwyer, GJ Jang, C Dean and MC Leake  
bioRxiv, 2024.05.17.594710

2. [Multifunctional polymerization domains determine the onset of epigenetic silencing in Arabidopsis](https://www.biorxiv.org/content/10.1101/2024.02.15.580496.abstract)  
A Schulten, GJ Jang, A Payne-Dwyer, M Fiedler, ML Nielsen, M Bienz, MC Leake and C Dean  
bioRxiv, 2024.02. 15.580496  

3. [Modular in vivo assembly of Arabidopsis FCA oligomers into condensates competent for RNA 3’ processing](https://doi.org/10.1038/s44318-025-00394-4)  
GJ Jang, AL Payne-Dwyer, R Maple, Z Wu, F Liu, SG Lopez, Y Wang, X Fang, MC Leake and C Dean  
**Now published in EMBO J** (2025) 44: 2056 - 2074  

4. [Single-molecular quantification of flowering control proteins within nuclear condensates in live whole Arabidopsis root](https://link.springer.com/protocol/10.1007/978-1-0716-2221-6_21)  
AL Payne-Dwyer and MC Leake  
Methods in Molecular Biology (Volume 2476): Chromosome Architecture pp 311-328 (2022)  
Also available via [open access preprint](https://arxiv.org/pdf/2108.13743)

Novel functionality here includes:  
- new methods for segmentation and two-channel alignment/registration
- saved `output.mat` files summarising the analysis
- periodicity: distribution-based estimates of periodic clustering in molecular assemblies  
- scripts for visualising correlated properties of tracks colocalised across two channels.  

## Set-up

To get the code, do one of the following: 
1. set up source control in Matlab with this [MathWorks protocol](https://blogs.mathworks.com/community/2014/10/20/matlab-and-git/)
2. use git to clone the repository, or
3. download directly:
- Click ‘View on Github’ at the top
- Click the green ‘Clone or download’ button and download the whole repository
- Put the folder in your Matlab path and unzip if necessary
- Make sure all code is added to the Matlab path using ‘Set path’

## Input data structure and format

The standard file format for ADEMScode is 16-bit OME TIFF.  The code uses `bioformats` and `bftools` from the [Open Microscopy Environment](https://www.openmicroscopy.org/) under open licence.
In principle, it is therefore also compatible with .czi and other image stack types listed in BioFormats. 

The input image sequence files must be organised in a nested folder hierarchy: `DATASET/DATE/SAMPLE/FIELD/IMAGES`  
i.e. in the format `"\*/2YYY-MM-DD/sample\*/field\*/\*.tif"`.  

`mergeFolders` is a macro for arranging folders into this structure, for example if alternating odd- and even-numbered acquisitions correspond to  brightfield and SlimVar sequences for each subsequent field of view.  
It also renames image stack files by timestamp using the metadata.txt files generated by MicroManager 1.4.

## Alignment / registration between image channels

*For data with multiple channels only*: the image channels are tracked independently, but the positions in the tracking data must later be adjusted for the colocalisation estimates to be accurate.  This requires us to generate an affine transform to map the positions of channel 2 onto those of channel 1, before we perform the tracking procedure.  The best practice is to align the microscope and then take long exposures of multiple fields-of-view for sub-diffractive, point-like objects which appear in both channels due to broad emission or bleed-through.  _FluoSpheres_ or _TetraSpeck_ beads of <200 nm diameter are particularly useful for this.  Alternatively, brightfield images can provide feature-rich, high signal-to-noise images of the same scene in both channels.

`generateBeadTransform`: inputs a single 2D TIFF image (either brightfield or a maximum projection of fluorescent beads) and then asks the user to specify matching pairs of points interactively.  The code interpolates these points and generates a 'tform' object in MATLAB.

## Segmentation

*NB*: It is most efficient to crop the input images to the region of interest _before_ segmentation, since this avoids ADEMScode having to perform computationally heavy tracking outside the user's region of interest.  

ADEMScode includes various custom functions for segmenting 2D areas of images, for example cells or organelles.  
Each segmentation method creates masks for distinct objects which are used later to group sets of tracks:

`thresholdSegment`: Defines a pixel intensity threshold using various different methods, such as the Otsu threshold.  
`edgeSegment`: Detects edges in the image and dilates to fill in regions in between.  
`watershedSegment`: Requires input segmentation `seedMask` from which a watershed transform is nucleated and applied to the image.  

The output ('**`_segmentation.mat`**') includes `CellObject`: a binary mask array the same size as the input image.  
`mask2seg` can be used to generate `_segmentation.mat` format directly from 2D TIFFs, for example if segmentation was performed outside MATLAB.  


## Tracking

The tracking software consists of a series of functions for opening image sequences, tracking bright particles over time and quantifying their intensity.  

`tracker`: the main tracking program, whose inputs are the filename (or folder name for unstacked .tifs) and a list of hyperparameters '`p`'.    
`[SpotsCh1, SpotsCh2, frame_average, p, meta_data, image_data, spotImages] = tracker(fileName,p)`  

### Parameters and settings
`p` is the parameter structure which is read in from the workspace, or otherwise set in code (see code comments for details):  
`readData` set to `0` for data preloaded as `image_label`, or `1` to specify .tif using a prompt.  
`show_output`: an option that can be used to view graphs and manually advance at each stage of the algorithm.  
`Cursor_mode`: set to `1` for the user to manually specify localised foci. The code will return intensity values at this point over the whole time series.  

### Subroutines
`extractImageSequence3`: extracts user set frames from .tif specified by image_label.  It can also open ASCII files and folders full of .tif frames.  
`ImEx1`: uses the OME `bftools` and `bioformats` modules to open various life science image formats.  
`LaserOn3`: calculates the first illuminated frame based on the maximum total intensity; for use when the excitation is not triggered by the camera.  
`FrameAverage2`: calculates an image averaged over a set number of frames.  
`findSpots4`: finds candidate foci using a range of deterministic kernel methods including top-hat filtering, Otsu thresholding and/or morphological transformations.  
`findSpotCentre3`: performs iterative Gaussian masking to find foci centre and total intensity.  
`fit2DgaussianFixedCenter2`: fits a constrained elliptical Gaussian mask to find `sigma_x`,`sigma_y` and central intensity.  
`MergeCoincidentCandidates2`: will use pairwise distances to remove candidates which are too close to be resolved.  
`iterate1DgaussianFixedCenter2`: finds the width of the point-spread-function (PSF) by masking with Gaussian masks of different sizes.  
`LinkSpots4`: links foci into tracks based on proximity.  

### Output
The output ('**`_TRACKS.mat`**') includes a copy of the input hyperparameters `p`, plus the following:  
`frame_average`: an average of the first few frames in the image sequence for reference.  
`SpotsCh1` and `SpotsCh2`: arrays of foci from one image sequence in the respective detector channels 1 and 2. Each row corresponds to an individual localisation. The columns contain the following information:  
1.	X coordinate (pixels)
2.	Y coordinate (pixels)
3.	Clipping_flag (not used)
4.	Mean local background pixel intensity (ADU counts)
5.	Total foci intensity, background corrected (this is the value in ADU detector counts used to calculate the track stoichiometry)
6.	X foci diameter, standard deviation (pixels)
7.	Y foci diameter, standard deviation (pixels)
8.	Peak intensity in a Gaussian fit (ADU counts)
9.	Frame index; the frame where the foci appear in the sequence
10.	Track index; foci in the same track have the same track index
11.	Signal to noise ratio (this is used later for the **sifting** step)
12.	Frame in which laser exposure began.

## Characteristic molecular brightness

To determine stoichiometry, periodicity or total molecule number, one must first estimate the typical intensity of a single fluorophore: the _characteristic molecular brightness_. For publication, I recommend reporting this as a number of photons per localisation (using the detector's gain factor in photoelectrons/ADU).  Within ADEMScode, only the value in ADU detector counts is needed, referred to as '`Isingle`'.  

Broadly, three methods are available to estimate this, listed in order of increasing accuracy for the specific use case:

### In vitro
1. Immobilise purified fluorophores to a surface, then track and find the average intensity of known single-molecule events (in ADUs, see column 5 of `SpotsCh1` and `SpotsCh2`).  

### In vivo
2. Extensively photobleach a sample, then track and find the average intensity of assumed single-molecule events (in ADUs, see column 5 of `SpotsCh1` and `SpotsCh2`).  
3. Track (or overtrack) and apply the Chung-Kennedy filter, then calculate the photobleaching step heights (in ADUs).  

#### Intensity distribution
`charMolBrightness`: for methods 1 and 2, this script will take tracking data and plot the intensity of foci detected after at least one 1/e photobleaching decay time.  
Plotting the intensity distribution of foci is useful in cases of sufficiently low background; you should have one clear peak at the characteristic molecular brightness and one close to the detector baseline.

#### Overtracking and filtering

`overTracker`: overtracking is the third method, used to see single photobleach steps by tracking them beyond the time at which they fall below the SNR threshold for sifting, typically due to near-complete photobleaching. This generates a modified tracking file called ('**`_BASELINE.mat`**').

`CKall`: the intensity of foci are typically too noisy to extract steps using direct averages, so edge-preserving filters are needed to smooth the traces. This script will run a Chung-Kennedy filter over the data and plot the individual photobleaching traces.  Aligning the plateaus and plotting the filtered intensity yields the distribution of photobleaching step heights. The modal value is the characteristic molecular brightness.  

`overTrackAll`: a script to overtrack multiple fields of view in a batch, producing multiple `_BASELINE.mat` files.  

`plotOverTracks`: a script to visualise selected traces of foci intensity over time, using either tracking data (`_TRACKS.mat`) or preferably, overtracking data from a `_BASELINE.mat` file.

## Analysis for Stoichiometry, Diffusivity, Periodicity and Colocalisation

The analysis step applies *sifting* (and if specified, segmentation masks) to the foci, then constructs the sifted tracks.   Where segmentation is applied, typically only the tracks within the segmented areas are retained.
The analysis step then tests for pairwise colocalisation between tracks, and summarises the track properties including stoichiometry and diffusivity according to the colocalisation status.  
*NB*: for the purposes of the code, 'linked / linking' is synonymous with 'colocalised / colocalising'.

### Routines

`colocalisedTrackAnalyser` is a function that runs on a single field of view containing two colour channels.  The main input is the tracking file (`TRACKS.mat`) containing the `SpotCh1` and `SpotCh2` arrays; it also requires the original image filename and a hyperparameter structure `params`.  Optionally, it can apply a segmentation mask '`_segmentation.mat`'.

`sampleTrackAnalyser` performs the same function in a loop over multiple image files in a nested folder structure, thereby aggregating results corresponding to multiple fields of view in the same dataset.
It uses same the list of hyperparameters '`params`' across the batch.    

### Parameters and settings
`params` is the parameter structure which is read in from the workspace, or otherwise set in code (see code comments for details).

### Output

This version of ADEMScode generates an output file ('**`_output.mat`**') for each analysis run.  It includes a copy of the input `params` and an `output` structure, which includes the arrays `TrackArrayCh1` and `TrackArrayCh2` that describe stoichiometry, diffusivity and other properties by track. These are collated from all image sequences in the two respective detector channels.  
Each row contains the information for an individual sifted track. The columns contain the following information:  
1.	Segment index
2.	Initial brightness of track (ADU detector counts; when normalised by the characteristic molecular brightness, this is the value that gives the track's stoichiometry as published)
3.	Diffusivity (µm²/s; this is the track's diffusivity as published)
4.	Diffusivity from first displacement (µm²/s)
5.	Mean foci diameter, standard deviation (pixels)
6.	Track index within this channel
7.	Filename ID
8.	Index of the longest colocalised track in the other channel
9.	Number of linked frames in this track
10. Index of the colocalised track in the other channel
11. Mean distance between tracks (pixels)
12. Track diameter parallel to segment long axis (pixels)
13. Track diameter perpendicular to segment long axis (pixels)
14. Length of track (in frames; post sifting so all tracks have 3+ frames)

The analyser script also appends the following rows to the foci arrays, resulting in the `AllSpots1` and `AllSpots2` arrays for the sifted foci:  

13. Index of colocalised foci in the other channel  
14. Overlap integral (a metric to estimate extent of colocalisation)  
15.	Track index of colocalised foci in the other channel  
16.	Distance between colocalised foci (pixels)  
17.	Field of view index  
18. Segment index  

The `output` structure also includes collated summary lists of specific metrics and properties for rapid interrogation, e.g.:  

`LinkedStoichsList` is a  list of all normalised stoichiometry values for colocalised tracks in each single channel, while  
`PairedStoichsList` shows the colocalised tracks of both channels as correlated pairs;  
`unlinkDiffsMean` summarises the diffusivities of uncolocalised tracks in the format `[Ch1 mean, Ch2 mean; Ch1 s.e.m., Ch2 s.e.m.]`.

### Handling and visualising the analysis

This version of ADEMScode includes several scripts to aid interrogation of the data and produce plots quickly and reproducibly, with aggregation of, or comparison between, different experimental datasets.  

`combineTrackingOutputs`: a script to aggregate multiple `output.mat` files, for example replicates of the same experiment tracked separately.  It stores the respective hyperparameter sets as `paramsA` and `paramsB`.
`BrunnerMunzelTest`: a two-tailed, non-parametric statistical test to distinguish lists of floating point values (e.g. diffusivity, stoichiometry of many tracks).  

The following scripts use a specific `output.mat` file as input to visualise the distribution of a particular metric for either colocalised, uncolocalised or total tracks in one of the channels.  
Various options include:  scatterplots, histograms, violin/beeswarm-style plots with boxplot, or kernel density estimates.  

`plotTrackFrequency`: plots the observed number of tracks per segment.
`plotStoichiometry`: plots the stoichiometry of tracks
`plotDiffusivity`: plots the diffusivity of tracks
`plotDwellTime`: plots the dwell time (duration over which tracks are colocalised)
`

The `cftool` fitting suite in MATLAB can also be used to fit models to the experimental data to discriminate heterogeneous states of assemblies, for example sums of Gaussian peaks for stoichiometry, or sums of Gamma distributions for the diffusivity. It generates handy `.sfit` files for later use e.g. with the plotting scripts above.

### Periodicity



### A note on Total Protein Number 

Analysis for total number of molecules per segment is independent of tracking.  Once a valid estimate for the characteristic molecular brightness is known, it therefore does not require the core ADEMScode package described above.  

For certain datasets, especially in microbiology e.g. monolayers of bacteria or yeast, the `CoPro` pipeline in MATLAB is appropriate (see [Adam Wollman's version](https://awollman.github.io/single-molecule-tools/deconvolution.html) and [Wollman et al. 2017](https://doi.org/10.7554/eLife.27451)).  It uses the characteristic molecular brightness and the segmentation structure in the same way as detailed above for ADEMScode.  

In the SlimVar publications (Payne-Dwyer et al, 2024), the total protein numbers are estimated from image stacks of plant nuclei using a dedicated Fiji/ImageJ macro.


